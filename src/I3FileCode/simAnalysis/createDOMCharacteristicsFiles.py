#!/usr/bin/env python

from icecube import icetray, dataclasses
from icecube.clsim import I3CLSimFunctionPolynomial, I3CLSimFunctionFromTable

from I3Tray import I3Units

import numpy, math
from os.path import expandvars

# taken from clsim/python/GetIceCubeDOMAngularSensitivity
def GetIceCubeDOMAngularSensitivity(holeIce=expandvars("$I3_BUILD/ice-models/resources/models/angsens/as.nominal")):
    """
    The relative collection efficiency of the DOM as a polynomial in the
    cosine of the photon's impact angle with respect to the DOM orientation
    (for IceCube, straight down).
    """
    
    coefficients = numpy.loadtxt(holeIce)[1:].tolist()
    print(coefficients)
    
    return I3CLSimFunctionPolynomial(coefficients)

# taken from clsim/python/GetIceCubeDOMAcceptance
def GetIceCubeDOMAcceptance(domRadius = 0.16510*I3Units.m, efficiency=1.0, highQE=False):
    """
    this is taken from photonics/lib/efficiency.h:
    
    Adopted into photonics Juli 1 2007 /Johan. Interpolation of data
    from Kotoyo Hoshina <kotoyo.hoshina@icecube.wisc.edu>: 
    Jan 15 K.Hoshina :
    Found a wrong value at 260nm whicn I didn't offer in July 1st 2007.
    Copied a value from 270nm.

          0.0002027029 -> 0.0000064522


    ROMEO wavelength effective area

    This is the table of photo-electron acceptance of the
    IceCube PMT after through the glass+gel + PMT photocathode,
    as a function of wavelength.
    It corresponds to a 0p.e. threshold.
    The injection angle (off-axis angle) is 0deg.
    
    The acceptances are calculated by:
    
    acceptance = NPEs generated by photo-cathode (0P.E threshold)\
              / Nphotons_inject_to_1m^2
    """
    dom2007a_eff_area = [
    0.0000064522,
    0.0000064522,
    0.0000064522,
    0.0000064522,
    0.0000021980,
    0.0001339040,
    0.0005556810,
    0.0016953000,
    0.0035997000,
    0.0061340900,
    0.0074592700,
    0.0090579800,
    0.0099246700,
    0.0105769000,
    0.0110961000,
    0.0114214000,
    0.0114425000,
    0.0111527000,
    0.0108086000,
    0.0104458000,
    0.0099763100,
    0.0093102500,
    0.0087516600,
    0.0083225800,
    0.0079767200,
    0.0075625100,
    0.0066377000,
    0.0053335800,
    0.0043789400,
    0.0037583500,
    0.0033279800,
    0.0029212500,
    0.0025334900,
    0.0021115400,
    0.0017363300,
    0.0013552700,
    0.0010546600,
    0.0007201020,
    0.0004843820,
    0.0002911110,
    0.0001782310,
    0.0001144300,
    0.0000509155]
    dom2007a_eff_area = numpy.array(dom2007a_eff_area)*I3Units.meter2 # apply units (this is an effective area)
    domArea = math.pi*domRadius**2.
    dom2007a_efficiency = efficiency*(dom2007a_eff_area/domArea)
    
    if highQE:
        wv, rde = numpy.loadtxt(expandvars('$I3_BUILD/ice-models/resources/models/wavelength/wv.rde')).T
        dom2007a_efficiency *= numpy.interp(260 + 10*numpy.arange(len(dom2007a_efficiency)), wv, rde)

    domEfficiency = I3CLSimFunctionFromTable(260.*I3Units.nanometer, 10.*I3Units.nanometer, dom2007a_efficiency)

    return domEfficiency

filePath = '/project/6008051/dvirhilu/P_ONE_dvirhilu/DOMCharacteristics/'
filenameAE = 'icecubeAngularEfficiency.dat'
filenameDE = 'icecubeDOMEfficiency.dat'

aeFile = open(filePath + filenameAE, 'w')
deFile = open(filePath + filenameDE, 'w')

angularEfficiency = GetIceCubeDOMAngularSensitivity()
domEfficiency = GetIceCubeDOMAcceptance()

print(angularEfficiency)
print(domEfficiency)
